<!doctype html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<title>Doser</title>
<style>
  :root{--bg:#f8fafc;--card:#fff;--b:#e5e7eb;--txt:#111827;--mut:#6b7280;--acc:#2563eb}
  *{box-sizing:border-box}
  body{font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--txt);margin:16px}
  h1{margin:8px 0 12px}
  .grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(280px,1fr))}
  .card{background:var(--card);border:1px solid var(--b);border-radius:12px;padding:14px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  label{font-size:12px;color:var(--mut)}
  input,select,button,textarea{font:inherit;border:1px solid var(--b);border-radius:10px;padding:8px 10px}
  button{cursor:pointer;background:#fff}
  button.primary{background:var(--acc);color:#fff;border-color:var(--acc)}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border:1px solid var(--b);padding:6px;text-align:center;font-size:14px}
  .mut{color:var(--mut);font-size:12px}
  .pill{display:inline-block;padding:4px 8px;border:1px solid var(--b);border-radius:999px;font-size:12px}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px}
  .status-table th, .status-table td { padding:6px; }
.status-table td:nth-child(3),
.status-table td:nth-child(4),
.status-table td:nth-child(5) { text-align:right; }
</style>
</head>

<h1>ESP8266 Doser</h1>
<div class="grid">
<div class="card">
  <div class="row" style="justify-content:space-between;align-items:baseline">
    <h3>Status</h3>
    <div class="mut kbd" id="clock">—</div>
  </div>
  <div class="mut">Next run per pump updates live. Times are local.</div>

  <table id="statusTable" class="status-table">
    <thead>
      <tr>
        <th style="text-align:left;">Pump</th>
        <th style="text-align:left;">State</th>
        <th style="text-align:right;">Delivered</th>
        <th style="text-align:right;">Next (countdown)</th>
        <th style="text-align:right;">Next (time)</th>
      </tr>
    </thead>
    <tbody id="statusBody">
      <tr><td colspan="5" class="mut">connecting…</td></tr>
    </tbody>
  </table>
</div>

  <div class="card">
    <h3>Wi-Fi / System</h3>
    <div class="row">
      <label>Hostname</label>
      <input id="hostname" placeholder="placeholder">
    </div>
    <div class="row">
      <label>SSID</label>
      <input id="ssid" placeholder="YOUR_WIFI">
    </div>
    <div class="row">
      <label>Password</label>
      <input id="pass" placeholder="YOUR_PASSWORD">
    </div>
    <div class="row">
      <button onclick="saveSettings()" class="primary">Save Settings</button>
      <span class="mut">Reboot after Wi-Fi changes.</span>
    </div>
  </div>
</div>

<div class="grid" id="pumpCards"></div>

<script>
let settings = null;
let lastStatus = null;
const NUM_PUMPS = 3;
const MAX_TIMES = 8;
const nextAtMs = Object.create(null); // map: pumpIdx -> epoch ms or null

function secToHHMM(sec){
  let h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60);
  return String(h).padStart(2,'0')+':'+String(m).padStart(2,'0');
}

function HHMMtoSec(hhmm){
  if (!hhmm || typeof hhmm !== 'string') return 0;
  const [hStr='0', mStr='0'] = hhmm.split(':');
  let h = parseInt(hStr, 10), m = parseInt(mStr, 10);
  if (!Number.isFinite(h)) h = 0;
  if (!Number.isFinite(m)) m = 0;
  h = Math.max(0, Math.min(23, h|0));
  m = Math.max(0, Math.min(59, m|0));
  return h*3600 + m*60;
}

function updateClock(){
  const el = document.getElementById('clock');
  if (!el) return;
  const now = new Date();
  el.textContent = new Intl.DateTimeFormat(undefined, {
    weekday:'short', month:'short', day:'2-digit',
    hour:'2-digit', minute:'2-digit', second:'2-digit'
  }).format(now);
}
setInterval(updateClock, 1000);
updateClock();

function pumpCard(i){
  return `
  <div class="card" id="pump${i}">
    <h3>Pump ${i}</h3>
    <div class="row">
      <label>ml/sec</label><input id="mlps_${i}" type="number" step="0.01" min="0" style="width:90px">
      <label>Duty</label><input id="duty_${i}" type="number" min="0" max="255" style="width:80px">
      <label>Run (s)</label><input id="runsec_${i}" type="number" min="1" max="600" style="width:90px">
      <label>Forward</label>
      <select id="dir_${i}">
        <option value="1">Normal</option>
        <option value="0">Reverse</option>
      </select>
    </div>

    <div class="row">
      <button onclick="doRun(${i})" class="primary">Run</button>
      <button onclick="doPrime(${i})">Prime</button>
      <button onclick="doPurge(${i})">Purge</button>
      <button onclick="doStop(${i})">Stop</button>
      <span class="pill" id="next_${i}">next: —</span>
    </div>

    <table>
      <thead><tr><th>#</th><th>Time</th><th>mL</th><th>Del</th></tr></thead>
      <tbody id="tbody_${i}">
        ${Array.from({length:MAX_TIMES}).map((_,t)=>`
          <tr>
            <td>${t+1}</td>
            <td><input id="time_${i}_${t}" type="time" value="00:00"></td>
            <td><input id="dose_${i}_${t}" type="number" min="0" step="0.1" style="width:90px" value="0"></td>
            <td><button onclick="delTime(${i},${t})">clr</button></td>
          </tr>
        `).join('')}
      </tbody>
    </table>

    <div class="row">
      <button onclick="saveSettings()" class="primary">Save Pump ${i}</button>
      <span class="mut">Only rows with mL &gt; 0 are stored.</span>
    </div>
  </div>`;
}

function renderPumpCards(){
  document.getElementById('pumpCards').innerHTML =
    Array.from({length:NUM_PUMPS}).map((_,i)=>pumpCard(i)).join('');
}

function fillSettingsUI(){
  if (!settings) return;
  hostname.value = settings.hostname || '';
  ssid.value = settings.wifi?.ssid || '';
  pass.value = settings.wifi?.pass || '';

  settings.pumps.forEach(p=>{
    document.getElementById('mlps_'+p.idx).value = p.mlPerSec;
    document.getElementById('duty_'+p.idx).value = p.duty;
    document.getElementById('runsec_'+p.idx).value = p.defaultRunSec || 5;
    document.getElementById('dir_'+p.idx).value = p.dirForward?1:0;

    // clear
    for(let t=0;t<MAX_TIMES;t++){
      document.getElementById(`time_${p.idx}_${t}`).value = '00:00';
      document.getElementById(`dose_${p.idx}_${t}`).value = 0;
    }
    (p.times||[]).forEach((o,ix)=>{
      if (ix<MAX_TIMES){
        document.getElementById(`time_${p.idx}_${ix}`).value = secToHHMM(o.sec||0);
        document.getElementById(`dose_${p.idx}_${ix}`).value = o.ml||0;
      }
    });
  });
}

function delTime(i,t){
  document.getElementById(`time_${i}_${t}`).value = '00:00';
  document.getElementById(`dose_${i}_${t}`).value = 0;
}

async function loadSettings(){
  const r = await fetch('/api/settings');
  settings = await r.json();
  fillSettingsUI();
}

async function saveSettings(){
  // collect
  const out = {
    hostname: hostname.value,
    wifi: { ssid: ssid.value, pass: pass.value },
    pumps: []
  };
  for (let i=0;i<NUM_PUMPS;i++){
    const times=[];
    for (let t=0;t<MAX_TIMES;t++){
      const hhmm = document.getElementById(`time_${i}_${t}`).value || "00:00";
      const ml = parseFloat(document.getElementById(`dose_${i}_${t}`).value||"0");
      if (ml>0){
        times.push({sec: HHMMtoSec(hhmm), ml});
      }
    }
    out.pumps.push({
      idx:i,
      mlPerSec: parseFloat(document.getElementById('mlps_'+i).value||"1"),
      duty: parseInt(document.getElementById('duty_'+i).value||"200"),
      defaultRunSec: parseInt(document.getElementById('runsec_'+i).value||"5"),
      dirForward: parseInt(document.getElementById('dir_'+i).value||"1"),
      times
    });
  }
  const r = await fetch('/api/settings', {method:'POST', body: JSON.stringify(out)});
  if (r.ok) alert('Saved!');
  else alert('Save failed');
}

async function postJSON(url,obj){
  return fetch(url,{method:'POST', body: JSON.stringify(obj)});
}
function doRun(i){ postJSON('/api/run',   {idx:i}); }
function doPrime(i){ postJSON('/api/prime',{idx:i,sec:3}); }
function doPurge(i){ postJSON('/api/purge',{idx:i,sec:2}); }
function doStop(i){ postJSON('/api/stop', {idx:i}); }

// --- STATUS TABLE WIRING ---
let lastS = null, lastSyncMs = 0, ticker = null;

function applyStatus(s){
  lastS = s;
  lastSyncMs = performance.now();

  const nowMs = Date.now();
  const pumps = Array.isArray(s?.pumps) ? s.pumps : [];
  pumps.forEach(p=>{
    if ((p.next_run_s ?? -1) >= 0) {
      nextAtMs[p.idx] = nowMs + (Number(p.next_run_s) || 0) * 1000;
    } else {
      nextAtMs[p.idx] = null;
    }
  });

  if (!ticker) ticker = setInterval(renderStatus, 1000);
  renderStatus();
}


function renderStatus(){
  if (!lastS) return;

  const ageSec = Math.floor((performance.now() - lastSyncMs) / 1000);
  const s = lastS;
  const pumps = Array.isArray(s?.pumps) ? s.pumps : [];

  // Build rows
  let rows = '';
  pumps.forEach(p=>{
    const start = Number(p.start_ms) ||0
    const dur = Number(p.dur_ms) || 0
    const upNow = (Number(s.uptime_ms) || 0) + ageSec*1000;

  // running countdown (clamp last second)
const msLeft   = Math.max(0, (start + dur) - upNow);
const secLeft  = msLeft <= 1000 ? 0 : Math.ceil(msLeft / 1000);
const runningNow = !!p.running && secLeft > 0;

// ===== Next-run (stable, no oscillation) =====
let nextCountdown = 'na';
let nextAbs = '—';

const target = nextAtMs[p.idx]; // may be null
if (target != null) {
  let remMs = target - Date.now();

  // Grace window: collapse sub-500ms jitter to zero to avoid 0/1s flap
  if (remMs < 500) remMs = 0;

  const nextSec = Math.max(0, Math.floor(remMs / 1000));
  nextCountdown = formatDuration(nextSec);

  // Only show absolute clock if it's not imminently due (prevents bounce)
  nextAbs = remMs >= 2000
    ? new Date(target).toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' })
    : '—';
}


const stateTxt      = runningNow ? 'RUNNING → ' + formatRunningCountdown(secLeft) : 'idle';
const deliveredTxt  = `~${(p.delivered_ml ?? 0).toFixed(1)} ml`;
//const nextCountdown = hasNext ? formatDuration(nextSec) : 'na';
//const nextAbs       = hasNext && nextSec > 0 ? formatClockFromNow(nextSec) : '—';

// build row (and pill if you still use it)
    rows += `<tr>
      <td class="kbd">#${p.idx}</td>
      <td>${stateTxt}</td>
      <td class="kbd">${deliveredTxt}</td>
      <td class="kbd">${nextCountdown}</td>
      <td class="kbd">${nextAbs}</td>
    </tr>`;

    // keep pills in sync if present
    const pill = document.getElementById('next_'+p.idx);
    if (pill) pill.textContent = `next: ${nextCountdown}`;
  });

  // Prefer the table; if it's missing, fall back to legacy statusArea (safe no-op otherwise)
  const tbody = document.getElementById('statusBody');
  if (tbody) {
    tbody.innerHTML = pumps.length ? rows : `<tr><td colspan="5" class="mut">No pump data yet…</td></tr>`;
  }
  const area = document.getElementById('statusArea');
  if (area && !tbody) {
    // Legacy fallback to keep something visible
    area.innerHTML = pumps.length
      ? rows.replace(/<tr>|<\/tr>/g,'').replace(/<td[^>]*>/g,'').replace(/<\/td>/g,' | ')
      : 'No pump data yet…';
  }
}

// Absolute clock for "Next (time)"
function formatClockFromNow(sec){
  if (!Number.isFinite(sec) || sec <= 0) return '—';
  const t = new Date(Date.now() + sec*1000);
  return t.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });
}



let sock=null;
function connectWS(){
  const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
  sock = new WebSocket(`${scheme}://${location.host}/ws`);
  sock.onopen = ()=> { /* auto status push every 1s */ };
  sock.onmessage = (ev)=> {
    try { applyStatus(JSON.parse(ev.data)); }
    catch (e) { console.error('Bad WS JSON:', e, ev.data); }
  };
  sock.onclose = ()=> setTimeout(connectWS, 1000);
}

function formatDuration(totalSeconds) {
  if (totalSeconds < 0) return 'na';

  const h = Math.floor(totalSeconds / 3600);
  const m = Math.floor((totalSeconds % 3600) / 60);
  const s = totalSeconds % 60;

  if (totalSeconds < 60) {
    // Under a minute → seconds only
    return `${s}s`;
  } else if (totalSeconds < 300) {
    // Hours → show h + m (ignore seconds)
    return `${m}m ${s}s`;
  } else if (h > 0) {
    // Hours → show h + m (ignore seconds)
    return `${h}h ${m}m`;
  } else {
    // Only minutes
    return `${m}m`;
  }
}


function formatRunningCountdown(totalSeconds){
  totalSeconds = Math.max(0, totalSeconds|0);
  const h = Math.floor(totalSeconds/3600);
  const m = Math.floor((totalSeconds%3600)/60);
  const s = totalSeconds % 60;
  if (h > 0) return `${h}h ${m}m ${s}s`;
  return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}
renderPumpCards();
loadSettings();
connectWS();
</script>
